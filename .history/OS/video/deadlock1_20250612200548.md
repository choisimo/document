 --------------------------------------------------------------------------------
1. 교착상태(Deadlock) 개요 및 특성
영상에서는 운영체제(Operating System)에서 발생하는 교착상태(Deadlock)에 대해 설명하며, 멀티프로그래밍 환경에서 여러 프로세스나 스레드가 한정된 컴퓨터 시스템 자원을 공유할 때 발생하는 문제라고 언급합니다
. 특정 스레드가 어떤 자원을 점유하고 다른 스레드가 점유한 또 다른 자원을 기다릴 때, 서로가 영원히 작업을 완료할 수 없는 상황이 발생하는데, 이를 교착상태라고 정의합니다. 이 개념은 6장에서 다룬 '활성 실패(Liveness failure)'의 일종으로 언급되며, 철학자들의 식사 문제(Dining Philosophers Problem)를 예시로 들어 설명됩니다
.
시스템 모델, 교착상태 특성, 교착상태 처리 방법 등이 논의의 주요 주제로 제시됩니다
.
1.1. 시스템 모델 (System Model)
시스템은 여러 자원들로 구성됩니다
. 자원들은 CPU 사이클, 메모리 공간, I/O 장치 등 다양한 유형(R1, R2, ..., Rm)으로 나뉘며, 각 자원 유형 Ri는 Wi개의 인스턴스(instances)를 가질 수 있습니다. 각 프로세스 또는 스레드는 자원을 다음과 같은 방식으로 활용합니다
:
•
요청(request): 필요한 자원을 요청합니다
.
•
사용(use): 요청한 자원을 할당받아 사용합니다
.
•
해제(release): 자원 사용을 완료하면 자원을 반납합니다
.
1.2. 교착상태 특성 (Deadlock Characterization)
교착상태는 다음 네 가지 필요 조건이 모두 동시에 충족될 때 발생할 수 있습니다
:
1.
상호 배제(Mutual Exclusion):
◦
오직 하나의 스레드(또는 프로세스)만이 한 번에 자원을 사용할 수 있습니다
.
◦
즉, 최소한 하나의 자원이 비공유 모드(non-sharable mode)로 점유되어야 합니다. 뮤텍스 락(mutex lock)이나 세마포(semaphore)와 같은 자원들이 이에 해당합니다
.
2.
점유 및 대기(Hold and Wait):
◦
자원을 최소한 하나 이상 점유하고 있는 스레드가 다른 스레드에 의해 점유된 추가적인 자원을 얻기 위해 대기하는 상태를 의미합니다
.
◦
영상에서 세마포 S1과 S2 예시를 통해 T1이 S1을 점유한 채 S2를 기다리고, T2가 S2를 점유한 채 S1을 기다리는 상황이 설명됩니다
.
3.
비선점(No Preemption):
◦
자원은 해당 스레드가 작업을 완료한 후 자발적으로만 해제될 수 있으며, 강제로 선점(preempted)될 수 없습니다
.
◦
스레드가 자발적으로 자원을 내려놓지 않으면 다른 스레드가 그 자원을 강제로 뺏을 수 없습니다
.
4.
순환 대기(Circular Wait):
◦
대기하는 스레드들의 집합 {T0, T1, ..., Tn}이 존재하여, T0는 T1이 점유한 자원을 기다리고, T1은 T2가 점유한 자원을 기다리며, ..., Tn-1은 Tn이 점유한 자원을 기다리고, Tn은 다시 T0가 점유한 자원을 기다리는 순환 고리가 형성되는 상태를 의미합니다
.
1.3. 라이브락 (Livelock)
라이브락은 데드락과 유사하지만, 스레드들이 완전히 멈춰있는 데드락과 달리 지속적으로 무언가를 시도하지만 실제로는 아무런 진전도 이루어지지 않는 상태를 말합니다
. 이는 복도에서 두 사람이 서로 비켜주려다가 계속 부딪히는 상황에 비유될 수 있습니다
.
•
예시: pthread_mutex_trylock 함수를 사용하여 스레드가 두 번째 뮤텍스를 얻지 못하면 첫 번째 뮤텍스마저 해제하는 방식으로 코드를 작성할 경우 발생할 수 있습니다
. 스레드들은 계속해서 락을 획득하고 해제하며 작업을 시도하지만, 임계 영역에 진입하지 못하고 무한히 반복하게 됩니다
.
--------------------------------------------------------------------------------
2. 교착상태 처리 방법 (Methods for Handling Deadlocks)
교착상태를 처리하는 방법은 크게 세 가지 접근법으로 나눌 수 있습니다
:
1.
교착상태 방지(Deadlock Prevention): 시스템이 교착상태에 진입하는 것을 아예 막는 방법입니다
.
2.
교착상태 회피(Deadlock Avoidance): 시스템이 교착상태가 될 수 있는 불안전한 상태(unsafe state)로 진입하지 않도록 동적으로 자원 할당을 검사하는 방법입니다
.
3.
교착상태 탐지(Deadlock Detection) 및 회복(Recovery from Deadlock): 시스템이 교착상태에 진입하는 것을 허용하고, 나중에 교착상태가 발생했는지 탐지한 후 회복하는 방법입니다
. 또한, 문제를 무시하고 교착상태가 시스템에 절대 발생하지 않는다고 가정하는 접근법도 있습니다
.
2.1. 교착상태 방지 (Deadlock Prevention)
교착상태 방지는 교착상태의 네 가지 필요 조건 중 하나 이상을 무효화함으로써 교착상태를 방지하는 방법입니다
.
•
상호 배제(Mutual Exclusion): 공유 가능한 자원(예: 읽기 전용 파일)에는 상호 배제가 필요하지 않지만, 공유 불가능한 자원(non-sharable resources)에는 반드시 적용되어야 하므로 이 조건을 완전히 제거하는 것은 어렵습니다
.
•
점유 및 대기(Hold and Wait):
◦
프로세스가 자원을 요청할 때, 다른 어떤 자원도 점유하고 있지 않음을 보장하는 방법입니다
.
◦
예를 들어, 프로세스는 실행을 시작하기 전에 필요한 모든 자원을 한꺼번에 요청하고 할당받거나, 어떤 자원도 할당되지 않은 상태에서만 자원을 요청할 수 있도록 합니다
.
◦
단점으로는 자원 활용률이 낮아지고 기아 상태(starvation)가 발생할 수 있습니다
.
•
비선점(No Preemption):
◦
만약 프로세스가 이미 일부 자원을 점유하고 있는 상태에서 즉시 할당받을 수 없는 다른 자원을 요청한다면, 현재 점유하고 있는 모든 자원을 강제로 해제(release)하도록 합니다
.
◦
선점된 자원들은 해당 프로세스가 기다리는 자원 목록에 추가되며, 프로세스는 원래 점유했던 자원과 새로 요청한 자원 모두를 다시 얻을 수 있을 때만 다시 시작됩니다
.
•
순환 대기(Circular Wait):
◦
모든 자원 유형에 대해 총체적인 순서(total ordering)를 부과하고, 각 프로세스가 자원을 이 순서에 따라 오름차순으로만 요청하도록 요구하는 방법입니다
.
◦
예를 들어, 뮤텍스 락(mutex locks)에 고유한 번호를 할당하고, 항상 낮은 번호의 락부터 높은 번호의 락 순서로 획득하도록 합니다
. 영상에서 first_mutex = 1, second_mutex = 5와 같이 번호를 부여하여 thread_two의 락 획득 순서가 wait(s2) 다음 wait(s1)과 같이 되면 순환 대기가 발생할 수 있음을 보여줍니다
.
◦
이 방법은 교착상태 방지에서 가장 일반적으로 사용되는 방법입니다
.
2.2. 교착상태 회피 (Deadlock Avoidance)
교착상태 회피는 시스템이 교착상태에 절대 진입하지 않도록 동적으로 자원 할당 상태를 검사합니다
. 이를 위해 시스템은 사전에 각 프로세스가 필요로 할 최대 자원 수를 알아야 합니다
.
•
자원 할당 상태(Resource-allocation state): 사용 가능한(available) 자원, 할당된(allocated) 자원, 프로세스의 최대 요구(maximum demands) 수에 의해 정의됩니다
.
•
안전 상태(Safe State):
◦
시스템이 안전 상태에 있다는 것은 모든 스레드가 작업을 완료할 수 있는 일련의 순서(<T1, T2, ..., Tn>)가 존재함을 의미합니다
.
◦
이 순서에서 각 Ti는 현재 사용 가능한 자원과 Tj(j < i)가 사용을 마친 후 반납할 자원만으로도 필요한 자원을 충족하여 작업을 완료할 수 있어야 합니다
.
◦
안전 상태이면 교착상태가 발생하지 않습니다. 그러나 불안전 상태(unsafe state)라고 해서 반드시 교착상태인 것은 아니지만, 교착상태가 발생할 가능성이 있습니다
.
◦
교착상태 회피 알고리즘은 시스템이 불안전 상태로 진입하는 것을 방지하는 것을 목표로 합니다
.
2.2.1. 회피 알고리즘 (Avoidance Algorithms)
•
자원 유형당 인스턴스가 하나인 경우(Single instance of a resource type): 자원 할당 그래프(Resource-Allocation Graph) 알고리즘을 사용합니다
.
◦
클레임 간선(Claim edge): 프로세스 Ti가 자원 Rj를 요청할 수 있음을 나타내는 점선 화살표(Ti --> Rj)입니다
. 프로세스 실행 전에 모든 클레임 간선이 그래프에 표시되어야 합니다
.
◦
요청 간선(Request edge): 스레드가 자원을 요청할 때 클레임 간선이 요청 간선(실선)으로 바뀝니다 (Ti → Rj)
.
◦
할당 간선(Assignment edge): 자원이 스레드에 할당될 때 요청 간선이 할당 간선(Ti ← Rj)으로 바뀝니다
.
◦
스레드가 자원을 해제하면 할당 간선은 다시 클레임 간선으로 바뀝니다
.
◦
자원 할당 그래프 알고리즘은 스레드 Ti가 자원 Rj를 요청할 때, 요청 간선을 할당 간선으로 변경하는 것이 자원 할당 그래프에 사이클(cycle)을 형성하지 않는 경우에만 요청을 승인합니다
.
◦
사이클이 없으면 교착상태가 없고, 사이클이 있으면 인스턴스가 하나일 때는 데드락, 여러 개일 때는 데드락 가능성(unsafe)이 있습니다
.
•
자원 유형당 인스턴스가 여러 개인 경우(Multiple instances of a resource type): **은행원 알고리즘(Banker's Algorithm)**을 사용합니다
.
◦
각 스레드는 사전에 자신이 필요로 할 **최대 자원 사용량(maximum use)**을 선언해야 합니다
.
◦
스레드가 자원을 요청할 때 대기해야 할 수도 있습니다
.
◦
모든 자원을 얻은 스레드는 유한한 시간 내에 자원을 반납해야 합니다
.
◦
은행원 알고리즘을 위한 자료 구조 (Data Structures)
:
▪
n: 프로세스(스레드)의 수.
▪
m: 자원 유형의 수.
▪
Available: 길이 m의 벡터. Available[j] = k는 자원 유형 Rj의 k개의 인스턴스가 사용 가능함을 나타냅니다
.
▪
Max: n x m 행렬. Max[i,j] = k는 프로세스 Pi가 자원 유형 Rj의 최대 k개의 인스턴스를 요청할 수 있음을 나타냅니다
.
▪
Allocation: n x m 행렬. Allocation[i,j] = k는 프로세스 Pi가 현재 자원 유형 Rj의 k개의 인스턴스를 할당받았음을 나타냅니다
.
▪
Need: n x m 행렬. Need[i,j] = k는 프로세스 Pi가 작업을 완료하기 위해 자원 유형 Rj의 k개의 인스턴스가 더 필요함을 나타냅니다. Need[i,j] = Max[i,j] – Allocation[i,j]
.
◦
안전성 알고리즘 (Safety Algorithm)
:
1.
Work (길이 m)와 Finish (길이 n) 벡터를 초기화합니다. Work = Available, Finish[i] = false (i = 0, 1, ..., n-1)
.
2.
다음 두 조건을 모두 만족하는 i를 찾습니다
: (a) Finish[i] == false (b) Need_i <= Work 만약 그러한 i가 없으면 4단계로 이동합니다
.
3.
Work = Work + Allocation_i. Finish[i] = true. 2단계로 돌아갑니다
.
4.
만약 모든 i에 대해 Finish[i] == true이면, 시스템은 안전 상태입니다
.
◦
자원 요청 알고리즘 (Resource-Request Algorithm for Process Pi)
: 프로세스 Pi가 자원 유형 Rj의 k개 인스턴스를 요청할 때(Request_i 벡터)
:
1.
만약 Request_i <= Need_i이면 2단계로 이동합니다. 그렇지 않으면, 프로세스가 최대 요청량을 초과했으므로 오류 조건을 발생시킵니다
.
2.
만약 Request_i <= Available이면 3단계로 이동합니다. 그렇지 않으면, 자원이 사용 가능하지 않으므로 Ti는 대기해야 합니다
.
3.
요청된 자원을 Ti에 할당하는 것을 가정하여 시스템 상태를 임시로 수정합니다
: Available = Available – Request_i; Allocation_i = Allocation_i + Request_i; Need_i = Need_i – Request_i;
4.
이 새로운 상태에서 안전성 알고리즘을 실행합니다
.
•
만약 안전하면, 자원이 Ti에 할당됩니다
.
•
만약 불안전하면, Ti는 대기해야 하며 이전 자원 할당 상태로 복원됩니다
.
◦
예시: 5개 스레드(T0-T4), 3개 자원 유형(A:10, B:5, C:7)의 스냅샷을 통해 은행원 알고리즘을 적용한 결과, <T1, T3, T4, T2, T0> 순서가 안전성 기준을 만족함을 보입니다
. T1이 (1,0,2)를 요청했을 때, 시스템이 안전 상태로 유지될 수 있음을 보여주는 추가 예시도 제공됩니다
.
2.3. 교착상태 탐지 (Deadlock Detection)
교착상태 탐지는 시스템이 교착상태에 진입하는 것을 허용하고, 나중에 교착상태 여부를 주기적으로 검사하여 탐지하는 방법입니다
.
•
자원 유형당 인스턴스가 하나인 경우(Single Instance of Each Resource Type): **대기 그래프(Wait-for graph)**를 유지합니다
.
◦
노드는 스레드를 나타내고, Ti → Tj는 스레드 Ti가 스레드 Tj를 기다리고 있음을 나타냅니다
.
◦
주기적으로 그래프에서 사이클을 탐지합니다. 사이클이 존재하면 교착상태가 존재합니다
.
◦
사이클 탐지 알고리즘은 n이 그래프의 정점(스레드) 수일 때 O(n^2)의 연산이 필요합니다
.
•
자원 유형당 인스턴스가 여러 개인 경우(Several Instances of a Resource Type): 은행원 알고리즘과 유사한 탐지 알고리즘을 사용합니다
.
◦
자료 구조
:
▪
Available: 길이 m의 벡터. 사용 가능한 자원의 수
.
▪
Allocation: n x m 행렬. 각 프로세스에 현재 할당된 자원의 수
.
▪
Request: n x m 행렬. 각 프로세스의 현재 요청량. Request[i][j] = k는 스레드 Ti가 자원 유형 Rj의 k개 인스턴스를 더 요청하고 있음을 나타냅니다
.
◦
탐지 알고리즘 (Detection Algorithm)
:
1.
Work (길이 m)와 Finish (길이 n) 벡터를 초기화합니다
: (a) Work = Available (b) Allocation_i != 0이면 Finish[i] = false, 그렇지 않으면 Finish[i] = true로 초기화합니다
.
2.
다음 두 조건을 모두 만족하는 i를 찾습니다
: (a) Finish[i] == false (b) Request_i <= Work 그러한 i가 없으면 4단계로 이동합니다
.
3.
Work = Work + Allocation_i. Finish[i] = true. 2단계로 돌아갑니다
.
4.
만약 일부 i에 대해 Finish[i] == false이면 시스템은 교착상태입니다. 이때 Finish[i] == false인 Ti는 교착상태에 빠진 스레드입니다
.
▪
이 알고리즘은 시스템이 교착상태인지 탐지하는 데 O(m x n^2)의 연산이 필요합니다
.
◦
예시: 5개 스레드(T0-T4), 3개 자원 유형(A:7, B:2, C:6)의 스냅샷을 통해 탐지 알고리즘을 적용합니다
. 초기 상태에서 <T0, T2, T3, T1, T4> 순서가 안전 기준을 만족하여 모든 Finish[i]가 true가 됩니다. 그러나 T2가 추가적으로 C 유형 자원 1개를 요청하는 상황이 발생하면, 탐지 알고리즘 수행 시 T1, T2, T3, T4는 Finish[i]가 false로 남아 교착상태가 존재함을 확인합니다
.
•
탐지 알고리즘 사용 시점 (Detection-Algorithm Usage)
:
◦
교착상태가 얼마나 자주 발생하는지.
◦
얼마나 많은 프로세스를 롤백(rollback)해야 하는지.
◦
자원 그래프에 많은 사이클이 존재할 때, 어떤 프로세스가 교착상태를 "유발"했는지 판단하기 어렵습니다
.
2.4. 교착상태로부터의 회복 (Recovery from Deadlock)
교착상태가 탐지된 후에는 시스템을 회복시켜야 합니다
.
•
프로세스 종료(Process Termination)
:
◦
모든 교착상태 프로세스 강제 종료(Abort all deadlocked processes): 교착상태에 연루된 모든 프로세스를 한꺼번에 종료합니다
.
◦
하나씩 종료(Abort one process at a time): 교착상태 사이클이 제거될 때까지 프로세스를 하나씩 종료합니다
.
◦
종료할 프로세스 선택 기준(Order to abort)
:
1.
프로세스의 우선순위(Priority of the process).
2.
프로세스가 지금까지 계산한 시간과 완료까지 남은 시간 (How long process has computed, and how much longer to completion).
3.
프로세스가 사용한 자원(Resources the process has used).
4.
프로세스 완료에 필요한 자원(Resources process needs to complete).
5.
종료해야 할 프로세스의 수(How many processes will need to be terminated).
6.
프로세스가 대화식(interactive)인지 배치(batch)인지 여부
.
•
자원 선점(Resource Preemption)
:
◦
희생자 선택(Selecting a victim): 교착상태에서 회복하기 위해 자원을 선점할 프로세스(희생자)를 선택하며, 이로 인한 비용을 최소화하는 것이 목표입니다
.
◦
롤백(Rollback): 선택된 희생자 프로세스를 안전한 상태로 되돌리고, 그 상태부터 다시 시작합니다
.
◦
기아 상태(Starvation): 동일한 프로세스가 계속해서 희생자로 선택될 수 있으므로, 롤백 횟수를 비용 요소에 포함하여 방지해야 합니다
.
-------------------------------------------------------------------------------- 