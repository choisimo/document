# ì œ 6ì¥: ë™ê¸°í™” ë„êµ¬ (Synchronization Tools) ğŸ”„

## ğŸ“– ëª©ì°¨ (Table of Contents)

1. [ê°œìš”](#ê°œìš”)
2. [ë°°ê²½ ë° ê¸°ë³¸ ê°œë…](#ë°°ê²½-ë°-ê¸°ë³¸-ê°œë…)
3. [ì„ê³„ êµ¬ì—­ ë¬¸ì œ](#ì„ê³„-êµ¬ì—­-ë¬¸ì œ)
4. [í”¼í„°ìŠ¨ì˜ í•´ê²°ì±…](#í”¼í„°ìŠ¨ì˜-í•´ê²°ì±…)
5. [í•˜ë“œì›¨ì–´ ì§€ì›](#í•˜ë“œì›¨ì–´-ì§€ì›)
6. [ë®¤í…ìŠ¤ ë½](#ë®¤í…ìŠ¤-ë½)
7. [ì„¸ë§ˆí¬ì–´](#ì„¸ë§ˆí¬ì–´)
8. [ëª¨ë‹ˆí„°](#ëª¨ë‹ˆí„°)
9. [í™œì„± ìƒíƒœì™€ êµì°© ìƒíƒœ](#í™œì„±-ìƒíƒœì™€-êµì°©-ìƒíƒœ)
10. [ê³ ì „ì ì¸ ë™ê¸°í™” ë¬¸ì œ](#ê³ ì „ì ì¸-ë™ê¸°í™”-ë¬¸ì œ)
11. [í•µì‹¬ ê°œë… ì •ë¦¬](#í•µì‹¬-ê°œë…-ì •ë¦¬)
12. [ì—°ìŠµ ë¬¸ì œ](#ì—°ìŠµ-ë¬¸ì œ)

---

## ê°œìš”

**ë™ê¸°í™” ë„êµ¬(Synchronization Tools)**ëŠ” ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ í™˜ê²½ì—ì„œ ë°ì´í„° ì¼ê´€ì„±ì„ ë³´ì¥í•˜ê³  í”„ë¡œì„¸ìŠ¤ ê°„ì˜ ìˆœì„œë¥¼ ì œì–´í•˜ëŠ” ì¤‘ìš”í•œ ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.

```mermaid
graph TD
    A[ë™ê¸°í™” ë„êµ¬] --> B[ë™ê¸°í™” ë¬¸ì œ ì‹ë³„]
    A --> C[í•´ê²°ì±… êµ¬í˜„]
    A --> D[ì„±ëŠ¥ ìµœì í™”]
    
    B --> B1[ê²½í•© ì¡°ê±´]
    B --> B2[ì„ê³„ êµ¬ì—­]
    B --> B3[ë°ì´í„° ë¶ˆì¼ì¹˜]
    
    C --> C1[ì†Œí”„íŠ¸ì›¨ì–´ í•´ê²°ì±…]
    C --> C2[í•˜ë“œì›¨ì–´ ì§€ì›]
    C --> C3[ê³ ìˆ˜ì¤€ ë™ê¸°í™” ë„êµ¬]
    
    C1 --> C11[í”¼í„°ìŠ¨ ì•Œê³ ë¦¬ì¦˜]
    C2 --> C21[ì›ìì  ëª…ë ¹ì–´]
    C3 --> C31[ë®¤í…ìŠ¤]
    C3 --> C32[ì„¸ë§ˆí¬ì–´]
    C3 --> C33[ëª¨ë‹ˆí„°]
    
    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e8f5e8
```

### ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì¥ì„ í†µí•´ ë‹¤ìŒì„ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
- ë™ì‹œì„±ì—ì„œ ë°œìƒí•˜ëŠ” ë¬¸ì œì ë“¤
- ì„ê³„ êµ¬ì—­ ë¬¸ì œì™€ í•´ê²° ìš”êµ¬ì‚¬í•­
- ë‹¤ì–‘í•œ ë™ê¸°í™” ë„êµ¬ë“¤ì˜ ì›ë¦¬ì™€ í™œìš©
- ê³ ì „ì ì¸ ë™ê¸°í™” ë¬¸ì œë“¤ê³¼ í•´ê²°ì±…

---

## ë°°ê²½ ë° ê¸°ë³¸ ê°œë…

### ğŸ’¡ ë™ì‹œì„±ê³¼ ë°ì´í„° ì¼ê´€ì„±

```mermaid
sequenceDiagram
    participant P1 as í”„ë¡œì„¸ìŠ¤ 1
    participant M as ê³µìœ  ë©”ëª¨ë¦¬
    participant P2 as í”„ë¡œì„¸ìŠ¤ 2
    
    Note over P1,P2: ê³µìœ  ë°ì´í„°: counter = 5
    
    P1->>M: register1 = counter (5)
    P2->>M: register2 = counter (5)
    P1->>P1: register1 = register1 + 1 (6)
    P2->>P2: register2 = register2 - 1 (4)
    P1->>M: counter = register1 (6)
    P2->>M: counter = register2 (4)
    
    Note over P1,P2: ê²°ê³¼: counter = 4 (ì˜ˆìƒ: 5)
```

í”„ë¡œì„¸ìŠ¤ë“¤ì€ **ë™ì‹œì— ì‹¤í–‰**ë  ìˆ˜ ìˆìœ¼ë©°, ì–¸ì œë“ ì§€ ì‹¤í–‰ì´ ë¶€ë¶„ì ìœ¼ë¡œ ì™„ë£Œëœ ìƒíƒœë¡œ ì¤‘ë‹¨ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¡œ ì¸í•´ **ê³µìœ  ë°ì´í„°ì— ëŒ€í•œ ë™ì‹œ ì ‘ê·¼**ì€ ë°ì´í„° ë¶ˆì¼ì¹˜(data inconsistency)ë¥¼ ì´ˆë˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ğŸ” ê²½í•© ì¡°ê±´ (Race Condition)

**ê²½í•© ì¡°ê±´**ì€ ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ê°€ ë™ì‹œì— ê³µìœ  ë°ì´í„°ì— ì ‘ê·¼í•  ë•Œ, ì‹¤í–‰ ìˆœì„œì— ë”°ë¼ ê²°ê³¼ê°€ ë‹¬ë¼ì§€ëŠ” ìƒí™©ì…ë‹ˆë‹¤.

#### ì‹¤ì œ ì˜ˆì œ: ì¹´ìš´í„° ì¦ê°€/ê°ì†Œ

```c
// ì „ì—­ ë³€ìˆ˜
int counter = 5;

// í”„ë¡œë“€ì„œ í”„ë¡œì„¸ìŠ¤
void producer() {
    register1 = counter;      // T0
    register1 = register1 + 1; // T1
    counter = register1;       // T4
}

// ì†Œë¹„ì í”„ë¡œì„¸ìŠ¤  
void consumer() {
    register2 = counter;       // T2
    register2 = register2 - 1; // T3
    counter = register2;       // T5
}
```

**ì‹¤í–‰ ìˆœì„œì™€ ê²°ê³¼:**
- T0: í”„ë¡œë“€ì„œ `register1 = counter` (register1 = 5)
- T1: í”„ë¡œë“€ì„œ `register1 = register1 + 1` (register1 = 6)
- T2: ì†Œë¹„ì `register2 = counter` (register2 = 5)
- T3: ì†Œë¹„ì `register2 = register2 - 1` (register2 = 4)
- T4: í”„ë¡œë“€ì„œ `counter = register1` (counter = 6)
- T5: ì†Œë¹„ì `counter = register2` (counter = 4)

**ê²°ê³¼:** counter = 4 (ì˜ˆìƒê°’: 5)

### ğŸ” í•´ê²°ì±…ì˜ í•„ìš”ì„±

ë°ì´í„° ì¼ê´€ì„±ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ì„œëŠ” **í˜‘ë ¥í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ì˜ ìˆœì„œ ìˆëŠ” ì‹¤í–‰ì„ ë³´ì¥í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜**ì´ í•„ìš”í•©ë‹ˆë‹¤.

---

## ì„ê³„ êµ¬ì—­ ë¬¸ì œ

### ğŸ“ ì„ê³„ êµ¬ì—­ (Critical Section) ì •ì˜

```mermaid
graph LR
    A[ì§„ì… êµ¬ì—­<br/>Entry Section] --> B[ì„ê³„ êµ¬ì—­<br/>Critical Section]
    B --> C[í‡´ì¶œ êµ¬ì—­<br/>Exit Section]
    C --> D[ë‚˜ë¨¸ì§€ êµ¬ì—­<br/>Remainder Section]
    D --> A
    
    style B fill:#ffebee
    style A fill:#e8f5e8
    style C fill:#fff3e0
    style D fill:#f3e5f5
```

nê°œì˜ í”„ë¡œì„¸ìŠ¤ {Pâ‚€, Pâ‚, ..., Pâ‚™â‚‹â‚}ë¡œ êµ¬ì„±ëœ ì‹œìŠ¤í…œì—ì„œ:

- **ì„ê³„ êµ¬ì—­**: ê³µí†µ ë³€ìˆ˜ë¥¼ ë³€ê²½í•˜ê±°ë‚˜, í…Œì´ë¸”ì„ ì—…ë°ì´íŠ¸í•˜ê±°ë‚˜, íŒŒì¼ì„ ì“°ëŠ” ë“±ì˜ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ì½”ë“œ ì„¸ê·¸ë¨¼íŠ¸
- **ì§„ì… êµ¬ì—­**: ì„ê³„ êµ¬ì—­ì— ë“¤ì–´ê°€ê¸° ìœ„í•œ í—ˆê°€ë¥¼ ìš”ì²­í•˜ëŠ” ì½”ë“œ
- **í‡´ì¶œ êµ¬ì—­**: ì„ê³„ êµ¬ì—­ì„ ë¹ ì ¸ë‚˜ì˜¨ í›„ ì‹¤í–‰ë˜ëŠ” ì½”ë“œ
- **ë‚˜ë¨¸ì§€ êµ¬ì—­**: ê·¸ ì™¸ì˜ ì½”ë“œ

### âš–ï¸ ì„ê³„ êµ¬ì—­ í•´ê²°ì±…ì˜ ìš”êµ¬ì‚¬í•­

```mermaid
graph TD
    A[ì„ê³„ êµ¬ì—­ í•´ê²°ì±…] --> B[ìƒí˜¸ ë°°ì œ<br/>Mutual Exclusion]
    A --> C[ì§„í–‰<br/>Progress]
    A --> D[ìœ í•œ ëŒ€ê¸°<br/>Bounded Waiting]
    
    B --> B1["í•œ í”„ë¡œì„¸ìŠ¤ê°€ ì„ê³„ êµ¬ì—­ì—<br/>ìˆìœ¼ë©´ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ëŠ”<br/>ì§„ì…í•  ìˆ˜ ì—†ë‹¤"]
    
    C --> C1["ì„ê³„ êµ¬ì—­ì— ì•„ë¬´ë„ ì—†ê³ <br/>ì§„ì…í•˜ë ¤ëŠ” í”„ë¡œì„¸ìŠ¤ê°€ ìˆìœ¼ë©´<br/>ì„ íƒ ê³¼ì •ì´ ë¬´í•œ ì—°ê¸°ë˜ì§€ ì•Šì•„ì•¼"]
    
    D --> D1["í•œ í”„ë¡œì„¸ìŠ¤ê°€ ì„ê³„ êµ¬ì—­<br/>ì§„ì… ìš”ì²­ í›„ í—ˆê°€ë°›ê¸°ê¹Œì§€<br/>ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì˜ ì§„ì… íšŸìˆ˜ì—<br/>ìƒí•œì´ ìˆì–´ì•¼"]
    
    style B fill:#ffebee
    style C fill:#e8f5e8
    style D fill:#fff3e0
```

1. **ìƒí˜¸ ë°°ì œ (Mutual Exclusion)**: í”„ë¡œì„¸ìŠ¤ Páµ¢ê°€ ìì‹ ì˜ ì„ê³„ êµ¬ì—­ì—ì„œ ì‹¤í–‰ ì¤‘ì´ë©´, ë‹¤ë¥¸ ì–´ë–¤ í”„ë¡œì„¸ìŠ¤ë„ ìì‹ ì˜ ì„ê³„ êµ¬ì—­ì—ì„œ ì‹¤í–‰ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

2. **ì§„í–‰ (Progress)**: ì„ê³„ êµ¬ì—­ì—ì„œ ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ê°€ ì—†ê³ , ìì‹ ì˜ ì„ê³„ êµ¬ì—­ì— ë“¤ì–´ê°€ê³ ì í•˜ëŠ” ì¼ë¶€ í”„ë¡œì„¸ìŠ¤ê°€ ì¡´ì¬í•œë‹¤ë©´, ë‹¤ìŒì— ì„ê³„ êµ¬ì—­ì— ë“¤ì–´ê°ˆ í”„ë¡œì„¸ìŠ¤ë¥¼ ì„ íƒí•˜ëŠ” ê³¼ì •ì´ ë¬´ê¸°í•œ ì—°ê¸°ë˜ì–´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤.

3. **ìœ í•œ ëŒ€ê¸° (Bounded Waiting)**: í”„ë¡œì„¸ìŠ¤ê°€ ì„ê³„ êµ¬ì—­ì— ë“¤ì–´ê°€ê¸° ìœ„í•œ ìš”ì²­ì„ í•œ í›„ ê·¸ ìš”ì²­ì´ í—ˆê°€ë˜ê¸°ê¹Œì§€ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ìì‹ ì˜ ì„ê³„ êµ¬ì—­ì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” íšŸìˆ˜ì— ëŒ€í•œ ìƒí•œ(bound)ì´ ì¡´ì¬í•´ì•¼ í•©ë‹ˆë‹¤.

---

## í”¼í„°ìŠ¨ì˜ í•´ê²°ì±…

### ğŸ§  í”¼í„°ìŠ¨ ì•Œê³ ë¦¬ì¦˜ (Peterson's Algorithm)

í”¼í„°ìŠ¨ì˜ í•´ê²°ì±…ì€ **ë‘ í”„ë¡œì„¸ìŠ¤**ë¥¼ ìœ„í•œ ì†Œí”„íŠ¸ì›¨ì–´ ê¸°ë°˜ í•´ê²°ì±…ì…ë‹ˆë‹¤.

```mermaid
graph TD
    subgraph "ê³µìœ  ë³€ìˆ˜"
        A[boolean flag[2]<br/>flag[0] = flag[1] = false]
        B[int turn<br/>ì´ˆê¸°ê°’: 0 ë˜ëŠ” 1]
    end
    
    subgraph "í”„ë¡œì„¸ìŠ¤ i"
        C[flag[i] = true<br/>ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì—ê²Œ ì¤€ë¹„ë¨ì„ ì•Œë¦¼]
        D[turn = j<br/>ìƒëŒ€ë°©ì—ê²Œ ìš°ì„ ê¶Œ ì–‘ë³´]
        E[while flag[j] && turn == j<br/>ìƒëŒ€ë°©ì´ ì¤€ë¹„ë˜ê³  ì°¨ë¡€ì´ë©´ ëŒ€ê¸°]
        F[ì„ê³„ êµ¬ì—­ ì‹¤í–‰]
        G[flag[i] = false<br/>ì„ê³„ êµ¬ì—­ ì¢…ë£Œë¥¼ ì•Œë¦¼]
    end
    
    C --> D --> E --> F --> G
    
    style F fill:#ffebee
    style A fill:#e8f5e8
    style B fill:#e8f5e8
```

#### êµ¬í˜„ ì½”ë“œ

```c
// ê³µìœ  ë³€ìˆ˜
boolean flag[2] = {false, false};  // í”„ë¡œì„¸ìŠ¤ ì¤€ë¹„ ìƒíƒœ
int turn = 0;                      // ëˆ„êµ¬ì˜ ì°¨ë¡€ì¸ì§€

// í”„ë¡œì„¸ìŠ¤ i (i = 0 ë˜ëŠ” 1)
void process_i() {
    while (true) {
        // ì§„ì… êµ¬ì—­
        flag[i] = true;           // ë‚˜ëŠ” ì¤€ë¹„ë¨
        turn = j;                 // ìƒëŒ€ë°©ì—ê²Œ ìš°ì„ ê¶Œ
        while (flag[j] && turn == j); // ìƒëŒ€ë°©ì´ ì¤€ë¹„ë˜ê³  ì°¨ë¡€ì´ë©´ ëŒ€ê¸°
        
        // ì„ê³„ êµ¬ì—­
        critical_section();
        
        // í‡´ì¶œ êµ¬ì—­
        flag[i] = false;          // ì„ê³„ êµ¬ì—­ ì¢…ë£Œ
        
        // ë‚˜ë¨¸ì§€ êµ¬ì—­
        remainder_section();
    }
}
```

### âœ… í”¼í„°ìŠ¨ í•´ê²°ì±…ì˜ ì •í™•ì„±

```mermaid
graph TD
    A[í”¼í„°ìŠ¨ ì•Œê³ ë¦¬ì¦˜] --> B[ìƒí˜¸ ë°°ì œ âœ“]
    A --> C[ì§„í–‰ âœ“]
    A --> D[ìœ í•œ ëŒ€ê¸° âœ“]
    
    B --> B1["PiëŠ” flag[j]==falseì´ê±°ë‚˜<br/>turn==iì¸ ê²½ìš°ì—ë§Œ ì§„ì…"]
    C --> C1["ëŒ€ê¸° ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•Šìœ¼ë©´<br/>ì§„ì… ê°€ëŠ¥"]
    D --> D1["ìƒëŒ€ë°©ì´ ìµœëŒ€ 1ë²ˆë§Œ<br/>ë¨¼ì € ì§„ì… ê°€ëŠ¥"]
    
    style A fill:#e1f5fe
    style B fill:#e8f5e8
    style C fill:#e8f5e8
    style D fill:#e8f5e8
```

### âš ï¸ í˜„ëŒ€ ì•„í‚¤í…ì²˜ì—ì„œì˜ í•œê³„

```mermaid
sequenceDiagram
    participant C as ì»´íŒŒì¼ëŸ¬/í”„ë¡œì„¸ì„œ
    participant T1 as ìŠ¤ë ˆë“œ 1
    participant T2 as ìŠ¤ë ˆë“œ 2
    participant M as ë©”ëª¨ë¦¬
    
    Note over C: ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ ëª…ë ¹ì–´ ì¬ë°°ì—´
    
    T1->>M: flag[0] = true
    T1->>M: turn = 1
    Note over C: ì¬ë°°ì—´ ë°œìƒ!
    T2->>M: turn = 0 (ì›ë˜ëŠ” flag[1] = trueê°€ ë¨¼ì €)
    T2->>M: flag[1] = true
    
    Note over T1,T2: ë‘˜ ë‹¤ ì„ê³„ êµ¬ì—­ ì§„ì… ê°€ëŠ¥!
```

í˜„ëŒ€ ì•„í‚¤í…ì²˜ì—ì„œëŠ” **ëª…ë ¹ì–´ ì¬ë°°ì—´(instruction reordering)**ë¡œ ì¸í•´ í”¼í„°ìŠ¨ ì•Œê³ ë¦¬ì¦˜ì´ ì œëŒ€ë¡œ ì‘ë™í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì˜ˆì‹œ:**
```c
// ì›ë³¸ ì½”ë“œ
x = 100;
flag = true;

// ì¬ë°°ì—´ëœ ì‹¤í–‰ ìˆœì„œ (ê°€ëŠ¥)
flag = true;
x = 100;
```

---

## í•˜ë“œì›¨ì–´ ì§€ì›

### ğŸ”§ í•˜ë“œì›¨ì–´ ëª…ë ¹ì–´

í˜„ëŒ€ ì‹œìŠ¤í…œì€ ì„ê³„ êµ¬ì—­ êµ¬í˜„ì„ ìœ„í•œ í•˜ë“œì›¨ì–´ ì§€ì›ì„ ì œê³µí•©ë‹ˆë‹¤.

#### Test-and-Set ëª…ë ¹ì–´

```mermaid
graph LR
    A[Test-and-Set ëª…ë ¹ì–´] --> B[í˜„ì¬ ê°’ ë°˜í™˜]
    A --> C[ìƒˆ ê°’ìœ¼ë¡œ ì„¤ì •]
    
    B --> D[ì›ìì ìœ¼ë¡œ ì‹¤í–‰]
    C --> D
    
    style A fill:#e1f5fe
    style D fill:#ffebee
```

```c
// Test-and-Set ëª…ë ¹ì–´ (í•˜ë“œì›¨ì–´ë¡œ êµ¬í˜„)
boolean test_and_set(boolean *target) {
    boolean rv = *target;  // í˜„ì¬ ê°’ì„ ì €ì¥
    *target = true;        // ìƒˆ ê°’ìœ¼ë¡œ ì„¤ì •
    return rv;             // ì´ì „ ê°’ ë°˜í™˜
}

// ìƒí˜¸ ë°°ì œ êµ¬í˜„
boolean lock = false;  // ê³µìœ  ë³€ìˆ˜

void process() {
    while (true) {
        while (test_and_set(&lock)); // ë½ íšë“ê¹Œì§€ ëŒ€ê¸°
        
        // ì„ê³„ êµ¬ì—­
        critical_section();
        
        lock = false;  // ë½ í•´ì œ
        
        // ë‚˜ë¨¸ì§€ êµ¬ì—­
        remainder_section();
    }
}
```

#### Compare-and-Swap ëª…ë ¹ì–´

```c
// Compare-and-Swap ëª…ë ¹ì–´
int compare_and_swap(int *value, int expected, int new_value) {
    int temp = *value;
    if (*value == expected)
        *value = new_value;
    return temp;
}
```

### ğŸ”’ ì›ìì  ë³€ìˆ˜ (Atomic Variables)

```c
#include <stdatomic.h>

atomic_int counter = 0;

void increment() {
    atomic_fetch_add(&counter, 1);  // ì›ìì  ì¦ê°€
}
```

---

## ë®¤í…ìŠ¤ ë½

### ğŸ” ë®¤í…ìŠ¤ ë½ ê°œë…

**ë®¤í…ìŠ¤(Mutex, Mutual Exclusion)**ëŠ” ê°€ì¥ ë‹¨ìˆœí•œ ë™ê¸°í™” ë„êµ¬ì…ë‹ˆë‹¤.

```mermaid
graph TD
    A[ë®¤í…ìŠ¤ ë½] --> B[acquire í•¨ìˆ˜]
    A --> C[release í•¨ìˆ˜]
    
    B --> B1["ë½ì´ ì‚¬ìš© ê°€ëŠ¥í•˜ë©´ íšë“<br/>ì‚¬ìš© ë¶ˆê°€ëŠ¥í•˜ë©´ ëŒ€ê¸°"]
    C --> C1["ë½ì„ í•´ì œí•˜ì—¬<br/>ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ì‚¬ìš© ê°€ëŠ¥í•˜ê²Œ"]
    
    subgraph "ë‚´ë¶€ êµ¬í˜„"
        D[boolean available = true]
    end
    
    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#e8f5e8
```

#### êµ¬í˜„

```c
// ë®¤í…ìŠ¤ ë½ êµ¬ì¡°ì²´
typedef struct {
    boolean available;
} mutex;

// ë½ íšë“
void acquire(mutex *m) {
    while (!m->available); // ë°”ìœ ëŒ€ê¸° (busy waiting)
    m->available = false;
}

// ë½ í•´ì œ
void release(mutex *m) {
    m->available = true;
}

// ì‚¬ìš© ì˜ˆì œ
mutex m = {true};

void process() {
    while (true) {
        acquire(&m);
        
        // ì„ê³„ êµ¬ì—­
        critical_section();
        
        release(&m);
        
        // ë‚˜ë¨¸ì§€ êµ¬ì—­
        remainder_section();
    }
}
```

### ğŸ”„ ìŠ¤í•€ë½ (Spinlock)

ë®¤í…ìŠ¤ ë½ì€ **ë°”ìœ ëŒ€ê¸°(busy waiting)**ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ **ìŠ¤í•€ë½**ì´ë¼ê³ ë„ ë¶ˆë¦½ë‹ˆë‹¤.

**ì¥ì :**
- ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ ì˜¤ë²„í—¤ë“œ ì—†ìŒ
- ì§§ì€ ì„ê³„ êµ¬ì—­ì— ì í•©

**ë‹¨ì :**
- CPU ì‚¬ì´í´ ë‚­ë¹„
- ìš°ì„ ìˆœìœ„ ì—­ì „ ë¬¸ì œ ê°€ëŠ¥ì„±

---

## ì„¸ë§ˆí¬ì–´

### ğŸ“Š ì„¸ë§ˆí¬ì–´ ê°œë…

**ì„¸ë§ˆí¬ì–´(Semaphore)**ëŠ” ì •ìˆ˜ ë³€ìˆ˜ Sì™€ ë‘ ê°œì˜ ì›ìì  ì—°ì‚° `wait()`ì™€ `signal()`ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤.

```mermaid
graph TD
    A[ì„¸ë§ˆí¬ì–´ S] --> B[wait ì—°ì‚°<br/>P ì—°ì‚°]
    A --> C[signal ì—°ì‚°<br/>V ì—°ì‚°]
    
    B --> B1["S ê°’ì„ ê°ì†Œ<br/>S < 0ì´ë©´ ëŒ€ê¸°"]
    C --> C1["S ê°’ì„ ì¦ê°€<br/>ëŒ€ê¸° ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ ê¹¨ì›€"]
    
    subgraph "ì„¸ë§ˆí¬ì–´ ìœ í˜•"
        D[ì´ì§„ ì„¸ë§ˆí¬ì–´<br/>ê°’: 0 ë˜ëŠ” 1]
        E[ì¹´ìš´íŒ… ì„¸ë§ˆí¬ì–´<br/>ê°’: ì œí•œ ì—†ìŒ]
    end
    
    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#e8f5e8
```

#### ê¸°ë³¸ ì—°ì‚°

```c
// wait ì—°ì‚° (P ì—°ì‚°)
void wait(semaphore *S) {
    S->value--;
    if (S->value < 0) {
        // í”„ë¡œì„¸ìŠ¤ë¥¼ ëŒ€ê¸° íì— ì¶”ê°€
        // í”„ë¡œì„¸ìŠ¤ë¥¼ ë¸”ë¡ ìƒíƒœë¡œ ì „í™˜
    }
}

// signal ì—°ì‚° (V ì—°ì‚°)  
void signal(semaphore *S) {
    S->value++;
    if (S->value <= 0) {
        // ëŒ€ê¸° íì—ì„œ í”„ë¡œì„¸ìŠ¤ í•˜ë‚˜ ì œê±°
        // í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¤€ë¹„ ìƒíƒœë¡œ ì „í™˜
    }
}
```

### ğŸ”§ ì„¸ë§ˆí¬ì–´ ì‚¬ìš© ì˜ˆì‹œ

#### 1. ì„ê³„ êµ¬ì—­ ë¬¸ì œ í•´ê²°

```c
semaphore mutex = 1;  // ì´ì§„ ì„¸ë§ˆí¬ì–´

void process() {
    while (true) {
        wait(&mutex);      // ì„ê³„ êµ¬ì—­ ì§„ì…
        
        // ì„ê³„ êµ¬ì—­
        critical_section();
        
        signal(&mutex);    // ì„ê³„ êµ¬ì—­ í‡´ì¶œ
        
        // ë‚˜ë¨¸ì§€ êµ¬ì—­
        remainder_section();
    }
}
```

#### 2. ì‹¤í–‰ ìˆœì„œ ë™ê¸°í™”

```mermaid
sequenceDiagram
    participant P1 as í”„ë¡œì„¸ìŠ¤ P1
    participant S as ì„¸ë§ˆí¬ì–´ synch
    participant P2 as í”„ë¡œì„¸ìŠ¤ P2
    
    Note over S: synch = 0 (ì´ˆê¸°ê°’)
    
    P1->>P1: S1 ì‹¤í–‰
    P1->>S: signal(synch)
    Note over S: synch = 1
    
    P2->>S: wait(synch)
    Note over S: synch = 0
    P2->>P2: S2 ì‹¤í–‰
    
    Note over P1,P2: S1ì´ S2ë³´ë‹¤ ë¨¼ì € ì‹¤í–‰ë¨ì„ ë³´ì¥
```

```c
semaphore synch = 0;  // ë™ê¸°í™” ì„¸ë§ˆí¬ì–´

// í”„ë¡œì„¸ìŠ¤ P1
void process1() {
    S1;              // ë¨¼ì € ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” êµ¬ë¬¸
    signal(&synch);  // P2ì—ê²Œ ì‹ í˜¸ ì „ì†¡
}

// í”„ë¡œì„¸ìŠ¤ P2  
void process2() {
    wait(&synch);    // P1ì˜ ì‹ í˜¸ ëŒ€ê¸°
    S2;              // ë‚˜ì¤‘ì— ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” êµ¬ë¬¸
}
```

### ğŸš« ì„¸ë§ˆí¬ì–´ ë¬¸ì œì 

```mermaid
graph TD
    A[ì„¸ë§ˆí¬ì–´ ì˜ëª»ëœ ì‚¬ìš©] --> B[signal â†’ wait]
    A --> C[wait â†’ wait]
    A --> D[ì—°ì‚° ëˆ„ë½]
    
    B --> B1["ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ê°€<br/>ë™ì‹œì— ì„ê³„ êµ¬ì—­ ì§„ì…"]
    C --> C1["í”„ë¡œì„¸ìŠ¤ê°€<br/>ì˜êµ¬ì ìœ¼ë¡œ ë¸”ë¡"]
    D --> D1["ì˜ˆìƒì¹˜ ëª»í•œ<br/>ê²°ê³¼ ë°œìƒ"]
    
    style A fill:#ffebee
    style B fill:#ffcdd2
    style C fill:#ffcdd2
    style D fill:#ffcdd2
```

**ì˜ëª»ëœ ì‚¬ìš© ì˜ˆì‹œ:**

1. **signal â†’ wait**: ìƒí˜¸ ë°°ì œ ì‹¤íŒ¨
```c
signal(&mutex);  // ì˜ëª»ëœ ìˆœì„œ!
// ì„ê³„ êµ¬ì—­
wait(&mutex);
```

2. **wait â†’ wait**: ì˜êµ¬ ë¸”ë¡
```c
wait(&mutex);
wait(&mutex);  // ë‘ ë²ˆì§¸ waitì—ì„œ ì˜êµ¬ ëŒ€ê¸°
```

3. **ì—°ì‚° ëˆ„ë½**: ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ë™ì‘

---

## ëª¨ë‹ˆí„°

### ğŸ—ï¸ ëª¨ë‹ˆí„° ê°œë…

**ëª¨ë‹ˆí„°(Monitor)**ëŠ” í”„ë¡œì„¸ìŠ¤ ë™ê¸°í™”ë¥¼ ìœ„í•œ ê³ ìˆ˜ì¤€ ì¶”ìƒí™” ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.

```mermaid
graph TD
    A[ëª¨ë‹ˆí„°] --> B[ê³µìœ  ë³€ìˆ˜]
    A --> C[í”„ë¡œì‹œì €ë“¤]
    A --> D[ì¡°ê±´ ë³€ìˆ˜]
    A --> E[ì´ˆê¸°í™” ì½”ë“œ]
    
    B --> B1["ë‚´ë¶€ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥"]
    C --> C1["ìƒí˜¸ ë°°ì œ ìë™ ë³´ì¥"]
    D --> D1["wait/signal ì—°ì‚°"]
    E --> E1["ëª¨ë‹ˆí„° ì‹œì‘ ì‹œ ì‹¤í–‰"]
    
    style A fill:#e1f5fe
    style C fill:#e8f5e8
```

#### ëª¨ë‹ˆí„° êµ¬ì¡°

```c
monitor MonitorName {
    // ê³µìœ  ë³€ìˆ˜ ì„ ì–¸
    shared_variable_declarations;
    
    // í”„ë¡œì‹œì € ì •ì˜
    procedure P1(...) { ... }
    procedure P2(...) { ... }
    ...
    procedure Pn(...) { ... }
    
    // ì¡°ê±´ ë³€ìˆ˜
    condition x, y;
    
    // ì´ˆê¸°í™” ì½”ë“œ
    initialization_code(...) { ... }
}
```

### ğŸ”„ ì¡°ê±´ ë³€ìˆ˜ (Condition Variables)

```mermaid
graph LR
    A[ì¡°ê±´ ë³€ìˆ˜ x] --> B[x.wait]
    A --> C[x.signal]
    
    B --> B1["í˜¸ì¶œí•œ í”„ë¡œì„¸ìŠ¤ë¥¼<br/>ì¤‘ë‹¨í•˜ê³  ëŒ€ê¸°"]
    C --> C1["ëŒ€ê¸° ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤<br/>í•˜ë‚˜ë¥¼ ì¬ì‹œì‘"]
    
    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#e8f5e8
```

#### ì¡°ê±´ ë³€ìˆ˜ ì—°ì‚°

```c
// x.wait() ì—°ì‚°
void x_wait() {
    // í˜„ì¬ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¡°ê±´ ë³€ìˆ˜ xì˜ ëŒ€ê¸° íì— ì¶”ê°€
    // í”„ë¡œì„¸ìŠ¤ë¥¼ ì¤‘ë‹¨í•˜ê³  ëª¨ë‹ˆí„° ë½ í•´ì œ
    // ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ x.signal()ì„ í˜¸ì¶œí•  ë•Œê¹Œì§€ ëŒ€ê¸°
}

// x.signal() ì—°ì‚°
void x_signal() {
    // ì¡°ê±´ ë³€ìˆ˜ xì˜ ëŒ€ê¸° íì—ì„œ í”„ë¡œì„¸ìŠ¤ í•˜ë‚˜ ì œê±°
    // í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¬ì‹œì‘
    // ëŒ€ê¸° ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ê°€ ì—†ìœ¼ë©´ ì•„ë¬´ ë™ì‘ ì•ˆ í•¨
}
```

### ğŸ½ï¸ ì˜ˆì œ: ì‹ì‚¬í•˜ëŠ” ì² í•™ì ë¬¸ì œ (ëª¨ë‹ˆí„° í•´ê²°ì±…)

```c
monitor DiningPhilosophers {
    enum {THINKING, HUNGRY, EATING} state[5];
    condition self[5];
    
    void pickup(int i) {
        state[i] = HUNGRY;
        test(i);
        if (state[i] != EATING)
            self[i].wait();
    }
    
    void putdown(int i) {
        state[i] = THINKING;
        test((i + 4) % 5);  // ì™¼ìª½ ì´ì›ƒ í™•ì¸
        test((i + 1) % 5);  // ì˜¤ë¥¸ìª½ ì´ì›ƒ í™•ì¸
    }
    
    void test(int i) {
        if ((state[(i + 4) % 5] != EATING) &&
            (state[i] == HUNGRY) &&
            (state[(i + 1) % 5] != EATING)) {
            state[i] = EATING;
            self[i].signal();
        }
    }
    
    initialization_code() {
        for (int i = 0; i < 5; i++)
            state[i] = THINKING;
    }
}
```

---

## í™œì„± ìƒíƒœì™€ êµì°© ìƒíƒœ

### ğŸ”„ í™œì„± ìƒíƒœ (Liveness)

**í™œì„± ìƒíƒœ**ëŠ” ì‹œìŠ¤í…œì´ í”„ë¡œì„¸ìŠ¤ì˜ ì§„í–‰ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ ì¶©ì¡±í•´ì•¼ í•˜ëŠ” ì†ì„± ì§‘í•©ì…ë‹ˆë‹¤.

```mermaid
graph TD
    A[í™œì„± ìƒíƒœ ì‹¤íŒ¨] --> B[êµì°© ìƒíƒœ<br/>Deadlock]
    A --> C[êµ¶ì£¼ë¦¼<br/>Starvation]
    A --> D[ìš°ì„ ìˆœìœ„ ì—­ì „<br/>Priority Inversion]
    
    B --> B1["ë‘˜ ì´ìƒì˜ í”„ë¡œì„¸ìŠ¤ê°€<br/>ë¬´ê¸°í•œ ìƒí˜¸ ëŒ€ê¸°"]
    C --> C1["í”„ë¡œì„¸ìŠ¤ê°€ ë¬´ê¸°í•œ<br/>ìì›ì„ í• ë‹¹ë°›ì§€ ëª»í•¨"]
    D --> D1["ë‚®ì€ ìš°ì„ ìˆœìœ„ê°€<br/>ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ë¸”ë¡"]
    
    style A fill:#ffebee
    style B fill:#ffcdd2
    style C fill:#fff3e0
    style D fill:#f3e5f5
```

### âš ï¸ êµì°© ìƒíƒœ ì˜ˆì‹œ

```c
semaphore S = 1, Q = 1;

// í”„ë¡œì„¸ìŠ¤ P0
wait(S);
wait(Q);
// ...
signal(Q);
signal(S);

// í”„ë¡œì„¸ìŠ¤ P1  
wait(Q);
wait(S);
// ...
signal(S);
signal(Q);
```

**êµì°© ìƒíƒœ ì‹œë‚˜ë¦¬ì˜¤:**
1. P0ê°€ `wait(S)` ì‹¤í–‰ â†’ S = 0
2. P1ì´ `wait(Q)` ì‹¤í–‰ â†’ Q = 0  
3. P0ê°€ `wait(Q)` ì‹¤í–‰ â†’ ëŒ€ê¸° (Q = 0)
4. P1ì´ `wait(S)` ì‹¤í–‰ â†’ ëŒ€ê¸° (S = 0)
5. **êµì°© ìƒíƒœ!** ë‘˜ ë‹¤ ì„œë¡œë¥¼ ê¸°ë‹¤ë¦¼

---

## ê³ ì „ì ì¸ ë™ê¸°í™” ë¬¸ì œ

### ğŸ­ ìœ í•œ ë²„í¼ ë¬¸ì œ (Producer-Consumer Problem)

```mermaid
graph LR
    A[í”„ë¡œë“€ì„œ] -->|ì•„ì´í…œ ìƒì‚°| B[ê³µìœ  ë²„í¼]
    B -->|ì•„ì´í…œ ì†Œë¹„| C[ì†Œë¹„ì]
    
    subgraph "ì„¸ë§ˆí¬ì–´"
        D[mutex = 1<br/>ìƒí˜¸ ë°°ì œ]
        E[full = 0<br/>ê°€ë“ ì°¬ ë²„í¼ ìˆ˜]
        F[empty = n<br/>ë¹ˆ ë²„í¼ ìˆ˜]
    end
    
    style B fill:#e1f5fe
    style D fill:#fff3e0
    style E fill:#ffebee
    style F fill:#e8f5e8
```

#### í•´ê²°ì±…

```c
semaphore mutex = 1;    // ë²„í¼ ì ‘ê·¼ ì œì–´
semaphore full = 0;     // ê°€ë“ ì°¬ ë²„í¼ ê°œìˆ˜
semaphore empty = n;    // ë¹ˆ ë²„í¼ ê°œìˆ˜

// í”„ë¡œë“€ì„œ
void producer() {
    while (true) {
        // ì•„ì´í…œ ìƒì‚°
        produce_item();
        
        wait(&empty);   // ë¹ˆ ë²„í¼ ëŒ€ê¸°
        wait(&mutex);   // ë²„í¼ ì ‘ê·¼ ê¶Œí•œ íšë“
        
        // ë²„í¼ì— ì•„ì´í…œ ì¶”ê°€
        add_to_buffer();
        
        signal(&mutex); // ë²„í¼ ì ‘ê·¼ ê¶Œí•œ í•´ì œ
        signal(&full);  // ê°€ë“ ì°¬ ë²„í¼ ìˆ˜ ì¦ê°€
    }
}

// ì†Œë¹„ì
void consumer() {
    while (true) {
        wait(&full);    // ê°€ë“ ì°¬ ë²„í¼ ëŒ€ê¸°
        wait(&mutex);   // ë²„í¼ ì ‘ê·¼ ê¶Œí•œ íšë“
        
        // ë²„í¼ì—ì„œ ì•„ì´í…œ ì œê±°
        remove_from_buffer();
        
        signal(&mutex); // ë²„í¼ ì ‘ê·¼ ê¶Œí•œ í•´ì œ
        signal(&empty); // ë¹ˆ ë²„í¼ ìˆ˜ ì¦ê°€
        
        // ì•„ì´í…œ ì†Œë¹„
        consume_item();
    }
}
```

### ğŸ“š ì½ê¸°-ì“°ê¸° ë¬¸ì œ (Readers-Writers Problem)

```mermaid
graph TD
    A[ë°ì´í„°ë² ì´ìŠ¤] --> B[ì½ê¸° í”„ë¡œì„¸ìŠ¤ë“¤<br/>ë™ì‹œ ì ‘ê·¼ ê°€ëŠ¥]
    A --> C[ì“°ê¸° í”„ë¡œì„¸ìŠ¤<br/>ë…ì  ì ‘ê·¼ í•„ìš”]
    
    B --> B1["ì—¬ëŸ¬ ê°œê°€ ë™ì‹œì—<br/>ì½ê¸° ê°€ëŠ¥"]
    C --> C1["í•˜ë‚˜ë§Œ ì“°ê¸° ê°€ëŠ¥<br/>ì½ê¸°ì™€ ë™ì‹œ ë¶ˆê°€"]
    
    style A fill:#e1f5fe
    style B fill:#e8f5e8
    style C fill:#ffebee
```

#### í•´ê²°ì±… (First Readers-Writers Problem)

```c
semaphore rw_mutex = 1;  // ì½ê¸°/ì“°ê¸° ìƒí˜¸ ë°°ì œ
semaphore mutex = 1;     // read_count ë³´í˜¸
int read_count = 0;      // í˜„ì¬ ì½ê¸° ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ ìˆ˜

// ì“°ê¸° í”„ë¡œì„¸ìŠ¤
void writer() {
    while (true) {
        wait(&rw_mutex);
        
        // ì“°ê¸° ìˆ˜í–‰
        write_data();
        
        signal(&rw_mutex);
    }
}

// ì½ê¸° í”„ë¡œì„¸ìŠ¤
void reader() {
    while (true) {
        wait(&mutex);
        read_count++;
        if (read_count == 1)    // ì²« ë²ˆì§¸ ì½ê¸° í”„ë¡œì„¸ìŠ¤
            wait(&rw_mutex);    // ì“°ê¸° í”„ë¡œì„¸ìŠ¤ ì°¨ë‹¨
        signal(&mutex);
        
        // ì½ê¸° ìˆ˜í–‰
        read_data();
        
        wait(&mutex);
        read_count--;
        if (read_count == 0)    // ë§ˆì§€ë§‰ ì½ê¸° í”„ë¡œì„¸ìŠ¤
            signal(&rw_mutex);  // ì“°ê¸° í”„ë¡œì„¸ìŠ¤ í—ˆìš©
        signal(&mutex);
    }
}
```

---

## í•µì‹¬ ê°œë… ì •ë¦¬

### ğŸ“ ë™ê¸°í™” ë„êµ¬ ë¹„êµ

| ë™ê¸°í™” ë„êµ¬ | ì¥ì  | ë‹¨ì  | ì ìš© ë¶„ì•¼ |
|------------|------|------|-----------|
| **ë®¤í…ìŠ¤ ë½** | â€¢ ë‹¨ìˆœí•¨<br/>â€¢ ë¹ ë¥¸ ì‘ë‹µ | â€¢ ë°”ìœ ëŒ€ê¸°<br/>â€¢ CPU ë‚­ë¹„ | ì§§ì€ ì„ê³„ êµ¬ì—­ |
| **ì„¸ë§ˆí¬ì–´** | â€¢ ë¸”ë¡œí‚¹ ëŒ€ê¸°<br/>â€¢ ì¹´ìš´íŒ… ê°€ëŠ¥ | â€¢ í”„ë¡œê·¸ë˜ë° ì˜¤ë¥˜ ê°€ëŠ¥ | ìì› ê´€ë¦¬ |
| **ëª¨ë‹ˆí„°** | â€¢ ê³ ìˆ˜ì¤€ ì¶”ìƒí™”<br/>â€¢ ì˜¤ë¥˜ ë°©ì§€ | â€¢ ì–¸ì–´/OS ì§€ì› í•„ìš” | ë³µì¡í•œ ë™ê¸°í™” |

### ğŸ” ì„ íƒ ê¸°ì¤€

```mermaid
graph TD
    A[ë™ê¸°í™” ë„êµ¬ ì„ íƒ] --> B[ì„ê³„ êµ¬ì—­ ê¸¸ì´]
    A --> C[ì‹œìŠ¤í…œ ìì›]
    A --> D[í”„ë¡œê·¸ë˜ë° ë³µì¡ë„]
    
    B --> B1[ì§§ìŒ: ë®¤í…ìŠ¤/ìŠ¤í•€ë½]
    B --> B2[ê¸º: ì„¸ë§ˆí¬ì–´/ëª¨ë‹ˆí„°]
    
    C --> C1[ì œí•œì : ë®¤í…ìŠ¤]
    C --> C2[í’ë¶€í•¨: ì„¸ë§ˆí¬ì–´]
    
    D --> D1[ë‹¨ìˆœí•¨: ë®¤í…ìŠ¤]
    D --> D2[ë³µì¡í•¨: ëª¨ë‹ˆí„°]
    
    style A fill:#e1f5fe
```

---

## ì—°ìŠµ ë¬¸ì œ

### ğŸ§© ë¬¸ì œ 1: ì„¸ë§ˆí¬ì–´ ì‚¬ìš©

ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì„ ë§Œì¡±í•˜ëŠ” ì„¸ë§ˆí¬ì–´ ê¸°ë°˜ í•´ê²°ì±…ì„ ì‘ì„±í•˜ì„¸ìš”:
- í”„ë¡œì„¸ìŠ¤ Aì˜ êµ¬ë¬¸ Xê°€ í”„ë¡œì„¸ìŠ¤ Bì˜ êµ¬ë¬¸ Yë³´ë‹¤ ë¨¼ì € ì‹¤í–‰ë˜ì–´ì•¼ í•¨
- í”„ë¡œì„¸ìŠ¤ Bì˜ êµ¬ë¬¸ Yê°€ í”„ë¡œì„¸ìŠ¤ Cì˜ êµ¬ë¬¸ Zë³´ë‹¤ ë¨¼ì € ì‹¤í–‰ë˜ì–´ì•¼ í•¨

**ë‹µì•ˆ:**
```c
semaphore sync1 = 0;  // A â†’ B ë™ê¸°í™”
semaphore sync2 = 0;  // B â†’ C ë™ê¸°í™”

// í”„ë¡œì„¸ìŠ¤ A
void processA() {
    X;                // êµ¬ë¬¸ X ì‹¤í–‰
    signal(&sync1);   // Bì—ê²Œ ì‹ í˜¸
}

// í”„ë¡œì„¸ìŠ¤ B  
void processB() {
    wait(&sync1);     // Aì˜ ì‹ í˜¸ ëŒ€ê¸°
    Y;                // êµ¬ë¬¸ Y ì‹¤í–‰
    signal(&sync2);   // Cì—ê²Œ ì‹ í˜¸
}

// í”„ë¡œì„¸ìŠ¤ C
void processC() {
    wait(&sync2);     // Bì˜ ì‹ í˜¸ ëŒ€ê¸°
    Z;                // êµ¬ë¬¸ Z ì‹¤í–‰
}
```

### ğŸ§© ë¬¸ì œ 2: ëª¨ë‹ˆí„° ì„¤ê³„

ìµœëŒ€ 3ëª…ì´ ë™ì‹œì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì»´í“¨í„°ì‹¤ì„ ëª¨ë‹ˆí„°ë¡œ ì„¤ê³„í•˜ì„¸ìš”.

**ë‹µì•ˆ:**
```c
monitor ComputerLab {
    int available_seats = 3;
    condition waiting;
    
    void enter() {
        if (available_seats == 0)
            waiting.wait();
        available_seats--;
    }
    
    void exit() {
        available_seats++;
        waiting.signal();
    }
}
```

### ğŸ§© ë¬¸ì œ 3: ì˜¤ë¥˜ ë¶„ì„

ë‹¤ìŒ ì½”ë“œì˜ ë¬¸ì œì ì„ ì°¾ê³  ìˆ˜ì •í•˜ì„¸ìš”:

```c
semaphore mutex = 1;

void process1() {
    wait(&mutex);
    // ì„ê³„ êµ¬ì—­
    signal(&mutex);
    signal(&mutex);  // ì¶”ê°€ signal
}

void process2() {
    wait(&mutex);
    // ì„ê³„ êµ¬ì—­  
    signal(&mutex);
}
```

**ë¬¸ì œì :** process1ì—ì„œ signalì„ ë‘ ë²ˆ í˜¸ì¶œí•˜ì—¬ mutex ê°’ì´ 2ê°€ ë  ìˆ˜ ìˆìŒ. ì´ë¡œ ì¸í•´ ë‘ í”„ë¡œì„¸ìŠ¤ê°€ ë™ì‹œì— ì„ê³„ êµ¬ì—­ì— ì§„ì…í•  ìˆ˜ ìˆìŒ.

**ìˆ˜ì •ì•ˆ:**
```c
void process1() {
    wait(&mutex);
    // ì„ê³„ êµ¬ì—­
    signal(&mutex);  // í•œ ë²ˆë§Œ í˜¸ì¶œ
}
```

---

### ğŸ“š ì°¸ê³  ìë£Œ

- **ìš´ì˜ì²´ì œ ê°œë…** - Abraham Silberschatz, Peter Baer Galvin, Greg Gagne
- **Modern Operating Systems** - Andrew S. Tanenbaum
- **Operating System Concepts with Java** - Abraham Silberschatz

### ğŸ”— ê´€ë ¨ ë§í¬

- [POSIX Threads Programming](https://computing.llnl.gov/tutorials/pthreads/)
- [Java Concurrency Tutorial](https://docs.oracle.com/javase/tutorial/essential/concurrency/)
- [Linux Kernel Synchronization](https://www.kernel.org/doc/Documentation/locking/)

---

*Â© 2024 Operating Systems Study Guide. ëª¨ë“  ê¶Œë¦¬ ë³´ìœ .*
