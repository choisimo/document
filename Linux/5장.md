# 5.1 파일 시스템 구조
- 부트블록 (Boot block)
```text
파일 시스템 시작부에 위치하고 보통 첫 번째 섹터 차지
리눅스 시작 시 사용되는 부트스트랩 코드가 저장되는 블록
```
- 슈퍼 블록 (Super block)
```text
전체 파일 시스템에 대한 정보를 저장
> 총 블록수, 사용 가능 i-node 개수, 사용 가능한 블록 비트맵, 블록 크기 ,사용 중(가능)인 블록수 등
```
- i-리스트 (i-list)
```text
각 파일을 나타내는 모든 i-node 들의 list
한 블록은 약 40개 정도의 i-node 포함
```
- 데이터 블록 (Data block)
```text
파일의 내용(데이터)를 저장하기 위한 블록들
```

## i-node (i-node)
```text
한 파일은 하나의 i-node를 가진다.
```
```text
파일에 대한 모든 정보를 가지고 있음.
> 파일 타입 : 일반 파일, 디렉터리, 블록 장치 (/dev/sda), 문자 장치 (/dev/tty) 등
> 파일 크기
> 사용 권한
> 파일 소유자, 그룹, 그외
> 접근 및 갱신 시간
> 데이터 블록에 대한 포인터(주소) 등
``` 

## 블록 포인터
- 데이터 블록에 대한 포인터
```text
> 파일의 내용을 저장하기 위해 할당된 데이터 블록의 주소
```
- 하나의 i-node 내의 블록 포인터
```text
> 직접 블록 포인터 : 10개
> 간접 블록 포인터 : 1개
> 이중 간접 블록 포인터 : 1개
> 참고 : 최근 파일 시스템에서는 삼중 블록 포인터를 포함하기도 함
```
- 최대 가리킬 수 있는 데이터 블록의 개수
```text
> 직접 블록 포인터 10개 -> 블록 10개
> 간접 블록 포인터 1개 -> 1024 개의 직접 블록 포인터
>> 가정 : 블록 포인터 크기 4 byte, 한 블록의 크기 4096 byte
> 이중 간접 블록 포인터 1개 -> 1024 개의 간접 블록 포인터 -> 1024 * 1024 개의 직접 블록 포인터
> 총 개수 : 1 * 10 + 1 * 1,024 + 1,024 * 1,024 = 1,049,610
```

## 파일 입출력 구현 
- 파일 입출력 구현을 위한 커널 내 자료구조
```text
> 파일 디스크립터 배열 (fd array)
> 열린 파일 테이블 (Open File Table)
> 동적 i-node 테이블 (Active i-node table)
```
<img src="https://github.com/choisimo/document/assets/150008602/b173b661-0b1e-4b28-935e-07550c2b4a5e">

## 파일 디스크립터 배열 (fd array)
```text
> 프로세스 당 하나씩 갖는다
```
- 파일 디스크립터 배열
```text
> 프로세스 내의 자료 구조
> 프로세스 내에서 열린 파일의 파일 디스크립터를 저장하기 위한 구조
> 열린 파일 테이블 엔트리를 가리킨다
```
- 파일 디스크립터
```text
> 파일 티스트립터 배열의 인덱스
> 열린 파일을 나타내는 번호
```

## 열린 파일 테이블 (Open File Table)
- 열린 파일 테이블 (file table)
```
> 커널 내의 자료구조
> 열려진 모든 파일 목록
> 파일 테이블 엔티리로 구성
> 파일을 열 때마다 파일 테이블 엔트리가 만들어짐
```
- 파일 테이블 엔트리 (file table entry)
```text
> 파일 상태 플래그 (read, write, append)
> 파일의 현재 위치 (current file position)
> 동적 i-node에 대한 포인터
```
## 동적 i-node 테이블 (Active i-node table)
- 동적 i-node 테이블 (Active i-node table)
```text
> 커널 내의 자료구조
> 열린 파일들의 i-node를 저장하는 테이블
> 열린 파일의 i-node의 모든 정보를 가지고 옴
```
- i-node
```text
> 하드 디스크에 저장되어 있는 파일에 대한 자료구조
> 한 파일에 하나의 i-node
> 하나의 파일에 대한 정보 저장
>> 소유자, 크기
>> 파일이 위치한 장치
>> 파일 내용 디스크 블록에 대한 포인터
```
## 파일을 위한 커널 자료 구조
- `fd = open("file", O_RDONLY);` 실행 시
```text
1. i-node를 찾아서 동적 i-node 테이블로 가져와 테이블 내에 하나의 엔트리 생성
2. 열린 파일 테이블에도 하나의 엔트리 생성하여 
   파일 위치, 플래그, 동적 i-node 에 대한 포인터 저장
3. 파일 디스크립터 배열에 엔트리를 만들어 인덱스(fd) 반환
```
- 열린 파일에 대해 읽거나 쓸 때, 데이터 블록 위치 찾는 방법<br>
<br>
<img src="https://github.com/choisimo/document/assets/150008602/e2daa91a-309d-4cae-bf8c-e1cfe5dd2fda"><br>
<br>
```text
열린 파일 테이블 엔트리에 저장된 
현재 파일 위치 정보 + 동적 i-node 내의 블록 포인터 정보 이용
```

- 한 파일을 두 번 열 때 자료구조<br>
<br>
<img src="https://github.com/choisimo/document/assets/150008602/2cf6f1c4-dc75-4cd4-aac2-493ed0cda272"><br>
```text
> 이미 해당 파일의 i-node 내용이 동적 i-node 테이블에 존재
> 열린 파일 테이블 내에 새로운 엔트리를 만들어야함 (현재 파일 위치, 파일 상태 플래그 새로 설정)
> fd 배열에도 새로운 엔트리 만들어 fd 반환
```

- `fd = dup(3);` 혹은 `fd = dup2(3,4);`<br>
<br>
<img src="https://github.com/choisimo/document/assets/150008602/799c0f96-8e78-42e2-8c44-fa80589de1e0">
<br>

```text
fd 배열 내에만 새로운 엔트리를 만듦
열린 파일 테이블 내의 동일한 파일 엔트리 가리키도록 함
```

# 5.2 파일 상태 정보

## 파일 상태 (file status)
- 파일 상태
```text
> 파일에 대한 모든 정보
> 블록수, 파일 타입, 사용 권한, 링크수, 파일 소유자의 사용자 ID, 그룹 ID, 파일 크기, 최종 수정 시간 등
```
```shell
$ ls -l hello.c
2 -rw-r--r-- 1 user group 600 11월 17일 15:33  hello.c
```

## 상태 정보 : stat() 시스템 호출 (System Call)
```text
> 파일 하나당 하나의 i-node 가 있으며, i-node 내에 파일에 대한 모든 상태 정보가 저장되어 있음
> lstat()과 stat()의 차이는 lstat은 대상이 심볼릭 링크일 때 링크가 가리키는 파일이 아니라
  링크 자체에 대한 정보
```
```C
#include <sys/types.h>
#include <sys/stat.h>

int stat(const char *filename. struct stat *buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *filename, struct stat *buf);
/**
    파일의 상태 정보를 가져와서 stat 구조체 buf에 저장.
    성공시 0, 실패시 -1 리턴
*/
```
## stat 구조체 (struct)
```C
struct stat {
    mode_t st_mode;     // 파일 타입과 사용권한
    ino_t st_ino;       // i-node 번호
    dev_t st_dev;       // 장치 번호
    dev_t st_rdev;      // 특수 파일 장치 번호
    nlink_t st_nlink;   // 링크 수
    uid_t st_uid;       // 소유자의 사용자 ID
    gid_t st_gid;       // 소유자의 그룹 ID
    off_t st_size;      // 파일 크기
    time_t st_atime;    // 최종 접근 시간
    time_t st_mtime;    // 최종 수정 시간
    time_t st_ctime;    // 최종 상태 변경 시간
    long st_blksize;    // 최종 블록 크기
    long st_blocks;     // 파일의 블록 수 
};
```
## 파일 타입
|||
|--|--|
|**파일 타입**|**설명**|
|`일반 파일`|데이터를 갖고 있는 텍스트 파일 또는 이진 파일|
|`디렉터리 파일`|파일의 이름들과 파일 정보에 대한 포인터를 포함하는 파일|
|`문자 장치 파일`|문자 단위로 데이터를 전송하는 장치를 나타내는 파일 <br> (입출력 장치, 예 : 터미널, 프린터, 키보드 등)|
|`블록 장치 파일`|블록 단위로 데이터를 전송하는 장치를 나타내는 파일 <br> (HDD, SSD와 같은 저장 장치, 예: /dev/sda)|
|`FIFO 파일`|프로세스 간 통신에 사용되는 파일로 이름 있는 파이프|
|`SOCKET`|네트워크를 통한 프로세스 간 통신에 사용되는 파일|
|`심볼릭 링크`|다른 파일을 가리키는 포인터 역할을 하는 파일|
||

## 파일 타입 검사 함수
- 파일 타입을 검사하기 위한 매크로 함수
```text
S_ISREG() : 대상이 일반 파일이면 1, 아니면 0 반환
```
